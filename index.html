<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Blamtech</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
  }
  canvas {
    display: block;
  }
  #ui {
    position: fixed;
    bottom: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    gap: 14px;
    padding: 16px;
    max-height: calc(100vh - 40px);
    overflow-y: auto;
    opacity: 0;
    transition: opacity 0.3s;
    font-family: 'Courier New', monospace;
    font-size: 11px;
    background: rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.1);
    scrollbar-width: thin;
    scrollbar-color: rgba(255,255,255,0.2) transparent;
  }
  #ui::-webkit-scrollbar { width: 4px; }
  #ui::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); }
  #ui.visible { opacity: 1; pointer-events: auto; }
  #ui { pointer-events: none; }
  .btn-group {
    display: flex;
    gap: 6px;
  }
  button {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.7);
    padding: 6px 12px;
    cursor: pointer;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    transition: background 0.2s;
    flex: 1;
  }
  button:hover {
    background: rgba(255,255,255,0.15);
  }
  button.active {
    background: rgba(255,255,255,0.25);
    border-color: rgba(255,255,255,0.5);
  }
  .slider-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
    color: rgba(255,255,255,0.7);
    letter-spacing: 0.1em;
    text-transform: uppercase;
  }
  .slider-label {
    display: flex;
    justify-content: space-between;
    cursor: pointer;
  }
  .slider-label span:last-child {
    color: rgba(255,255,255,0.4);
  }
  .slider-group:focus-within .slider-label span:last-child {
    color: rgba(255,255,255,0.9);
  }
  input[type=range] {
    -webkit-appearance: none;
    appearance: none;
    width: 120px;
    height: 2px;
    background: rgba(255,255,255,0.2);
    outline: none;
    cursor: pointer;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 10px;
    height: 10px;
    background: rgba(255,255,255,0.7);
    border-radius: 50%;
  }
  input[type=range]:focus {
    outline: none;
    background: rgba(255,255,255,0.5);
  }
  input[type=range]:focus::-webkit-slider-thumb {
    background: #fff;
    box-shadow: 0 0 0 2px rgba(255,255,255,0.4);
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div class="btn-group">
    <button id="btnColor" class="active">Color</button>
    <button id="btnBW">B&amp;W</button>
  </div>
  <div class="slider-group">
    <label class="slider-label" for="linesSlider">
      <span>Shapes</span>
      <span id="linesVal">2</span>
    </label>
    <input type="range" id="linesSlider" min="1" max="6" step="1" value="2">
  </div>
  <div class="slider-group">
    <label class="slider-label" for="trailSlider">
      <span>Trail</span>
      <span id="trailVal">53</span>
    </label>
    <input type="range" id="trailSlider" min="0" max="120" step="1" value="53">
  </div>
  <div class="slider-group">
    <label class="slider-label" for="vertSlider">
      <span>Vertices</span>
      <span id="vertVal">4</span>
    </label>
    <input type="range" id="vertSlider" min="2" max="16" step="1" value="4">
  </div>
  <div class="slider-group">
    <label class="slider-label" for="gapSlider">
      <span>Gap</span>
      <span id="gapVal">1</span>
    </label>
    <input type="range" id="gapSlider" min="1" max="8" step="1" value="1">
  </div>
  <div class="slider-group">
    <label class="slider-label" for="fadeSlider">
      <span>Fade</span>
      <span id="fadeVal">med</span>
    </label>
    <input type="range" id="fadeSlider" min="1" max="10" step="1" value="5">
  </div>
  <div class="slider-group">
    <label class="slider-label" for="speedSlider">
      <span>Speed</span>
      <span id="speedVal">1.0×</span>
    </label>
    <input type="range" id="speedSlider" min="0.2" max="4" step="0.1" value="1">
  </div>
  <div class="slider-group">
    <label class="slider-label" for="thickSlider">
      <span>Thickness</span>
      <span id="thickVal">1</span>
    </label>
    <input type="range" id="thickSlider" min="1" max="10" step="0.5" value="1">
  </div>
  <div class="slider-group">
    <label class="slider-label" for="curveSlider">
      <span>Curve</span>
      <span id="curveVal">0</span>
    </label>
    <input type="range" id="curveSlider" min="0" max="10" step="1" value="0">
  </div>
  <div class="slider-group">
    <label class="slider-label" for="wanderSlider">
      <span>Wander</span>
      <span id="wanderVal">3</span>
    </label>
    <input type="range" id="wanderSlider" min="0" max="10" step="1" value="3">
  </div>
  <div class="slider-group">
    <label class="slider-label" for="fpsSlider">
      <span>FPS</span>
      <span id="fpsVal">60</span>
    </label>
    <input type="range" id="fpsSlider" min="1" max="60" step="1" value="60">
  </div>
  <div class="btn-group">
    <button id="btnRandom" style="margin-top:4px">Randomize</button>
  </div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// Offscreen canvas for grayscale rendering before dithering
const offscreen = document.createElement('canvas');
const octx = offscreen.getContext('2d');

let W, H;
let colorMode = true;
let trails = [];
let speedMult = 1;
let gapOverride = 1;
let trailOverride = 53; // explicit history length, 0 = no trail
let numVertices = 4;
let targetFps = 60;
let fadeAlpha = 4 / 9; // matches default slider value 5: (5-1)/9
let lineThickness = 1;
let cornerRadius = 0; // Catmull-Rom tension, 0 = straight lines, 1 = fully curved
let lastFrameTime = 0;
let wanderSpeed = 3; // 0 = off, 1–10
let debugMode = false;
let debugPrev = {}; // saved state for restoring after debug

// Wander: each property has a current float value and a slow random velocity
const wander = {
  fade:      { val: 5,   min: 1,   max: 10,  step: 1,   vel: 0 },
  speed:     { val: 1,   min: 0.2, max: 4,   step: 0.1, vel: 0 },
  thickness: { val: 1,   min: 1,   max: 10,  step: 0.5, vel: 0 },
  vertices:  { val: 4,   min: -12, max: 16,  step: 1,   vel: 0, fold: 2 },
  trail:     { val: 53,  min: -120, max: 120, step: 1,   vel: 0, fold: 0 },
  shapes:    { val: 2,   min: -4,  max: 6,   step: 1,   vel: 0, fold: 1 },
  curve:     { val: 0,   min: -10, max: 10,  step: 1,   vel: 0, fold: 0 },
};

let wanderTimer = 0;
const WANDER_INTERVAL = 500; // ms between wander ticks
const NUM_SHAPES = 2;

// 8×8 Bayer ordered dither matrix (values 0–63, normalized to 0–1)
const BAYER8 = [
   0, 32,  8, 40,  2, 34, 10, 42,
  48, 16, 56, 24, 50, 18, 58, 26,
  12, 44,  4, 36, 14, 46,  6, 38,
  60, 28, 52, 20, 62, 30, 54, 22,
   3, 35, 11, 43,  1, 33,  9, 41,
  51, 19, 59, 27, 49, 17, 57, 25,
  15, 47,  7, 39, 13, 45,  5, 37,
  63, 31, 55, 23, 61, 29, 53, 21
].map(v => v / 64);

// Centripetal Catmull-Rom bezier handles for segment p1→p2.
// Knot intervals = sqrt(Euclidean distance), which prevents cusps and
// self-intersections when control points are unevenly spaced.
function centripetalHandles(p0, p1, p2, p3, tension) {
  const d01 = Math.sqrt(Math.hypot(p1.x - p0.x, p1.y - p0.y)) || 1e-4;
  const d12 = Math.sqrt(Math.hypot(p2.x - p1.x, p2.y - p1.y)) || 1e-4;
  const d23 = Math.sqrt(Math.hypot(p3.x - p2.x, p3.y - p2.y)) || 1e-4;
  const m1x = tension * d12 * ((p1.x-p0.x)/d01 - (p2.x-p0.x)/(d01+d12) + (p2.x-p1.x)/d12);
  const m1y = tension * d12 * ((p1.y-p0.y)/d01 - (p2.y-p0.y)/(d01+d12) + (p2.y-p1.y)/d12);
  const m2x = tension * d12 * ((p2.x-p1.x)/d12 - (p3.x-p1.x)/(d12+d23) + (p3.x-p2.x)/d23);
  const m2y = tension * d12 * ((p2.y-p1.y)/d12 - (p3.y-p1.y)/(d12+d23) + (p3.y-p2.y)/d23);
  return {
    cp1x: p1.x + m1x / 3,
    cp1y: p1.y + m1y / 3,
    cp2x: p2.x - m2x / 3,
    cp2y: p2.y - m2y / 3,
  };
}

function getTrailLength(count) {
  return Math.round(60 - (count - 1) * 7);
}


function resize() {
  W = canvas.width = offscreen.width = window.innerWidth;
  H = canvas.height = offscreen.height = window.innerHeight;
  // Clear offscreen to black on resize
  octx.fillStyle = '#000';
  octx.fillRect(0, 0, W, H);
}

class Corner {
  constructor() {
    this.x = Math.random() * W;
    this.y = Math.random() * H;
    this.vx = (Math.random() * 3 + 1.5) * (Math.random() < 0.5 ? 1 : -1);
    this.vy = (Math.random() * 3 + 1.5) * (Math.random() < 0.5 ? 1 : -1);
    this.lerpTarget = null; // merge destination vertex to lerp toward
    this.lerpAge = 0;
  }
  update() {
    if (this.lerpTarget) {
      this.lerpAge++;
      const dx = (this.lerpTarget.x + this.lerpTarget.vx * speedMult) - this.x;
      const dy = (this.lerpTarget.y + this.lerpTarget.vy * speedMult) - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const step = Math.min(7 * speedMult, dist);
      this.x += (dx / dist) * step;
      this.y += (dy / dist) * step;
      return;
    }
    this.x += this.vx * speedMult;
    this.y += this.vy * speedMult;
    if (this.x <= 0) { this.x = 0; this.vx = Math.abs(this.vx); }
    if (this.x >= W) { this.x = W; this.vx = -Math.abs(this.vx); }
    if (this.y <= 0) { this.y = 0; this.vy = Math.abs(this.vy); }
    if (this.y >= H) { this.y = H; this.vy = -Math.abs(this.vy); }
  }
  isArrived() {
    if (!this.lerpTarget) return false;
    const dx = this.lerpTarget.x - this.x;
    const dy = this.lerpTarget.y - this.y;
    return dx * dx + dy * dy < 36 || this.lerpAge > 600;
  }
}

class Shape {
  constructor(numCorners, hue, trailLength, drawStep, origin) {
    this.numCorners = numCorners;
    this.hue = hue;
    this.trailLength = trailLength;
    this.drawStep = drawStep;
    this.corners = Array.from({length: numCorners}, () => {
      const c = new Corner();
      if (origin) {
        c.x = origin.x + (Math.random() - 0.5) * 24;
        c.y = origin.y + (Math.random() - 0.5) * 24;
      }
      return c;
    });
    this.history = [];
    this.dying = false;
  }

  isDead() {
    return this.dying && this.history.every(e => e.alpha === 0);
  }

  update() {
    if (this.trailLength > 0) {
      // Decay stored alpha of existing entries — changing fadeAlpha only affects
      // future decay rate, not already-stored values, so no shimmer on wander
      if (fadeAlpha > 0 && this.history.length > 0) {
        const decayFactor = Math.pow(0.01, fadeAlpha / this.trailLength);
        this.history.forEach(e => { e.alpha *= decayFactor; });
      }
      this.history.push({ pts: this.corners.map(c => ({x: c.x, y: c.y})), alpha: this.dying ? 0 : 1.0, thickness: lineThickness, curve: cornerRadius });
      if (this.history.length > this.trailLength) this.history.shift();
    }
    this.corners.forEach(c => c.update());
    if (this.corners.length > 2) {
      const arrived = this.corners.find(c => c.isArrived());
      if (arrived) {
        const target = arrived.lerpTarget;
        // Boost target in its current direction
        const spd = Math.sqrt(arrived.vx ** 2 + arrived.vy ** 2);
        const tspd = Math.sqrt(target.vx ** 2 + target.vy ** 2);
        if (tspd > 0) {
          target.vx += (target.vx / tspd) * spd * 0.3;
          target.vy += (target.vy / tspd) * spd * 0.3;
        }
        const minSpd = Math.sqrt(1.5 ** 2 + 1.5 ** 2);
        const newSpd = Math.sqrt(target.vx ** 2 + target.vy ** 2);
        if (newSpd < minSpd) {
          const scale = newSpd > 0 ? minSpd / newSpd : 1;
          target.vx = newSpd > 0 ? target.vx * scale : (Math.random() < 0.5 ? 1 : -1) * minSpd * Math.SQRT1_2;
          target.vy = newSpd > 0 ? target.vy * scale : (Math.random() < 0.5 ? 1 : -1) * minSpd * Math.SQRT1_2;
        }
        this.corners = this.corners.filter(c => c !== arrived);
      }
    }
    // If still over target and no lerp in flight, kick off another
    if (this.corners.length > numVertices && !this.corners.some(c => c.lerpTarget)) {
      this.removeVertex();
    }
    this.hue = (this.hue + 0.4) % 360;
  }

  // Add a vertex at the centripetal Catmull-Rom curve midpoint (t=0.5) of a
  // random edge, computed via de Casteljau on the centripetal bezier handles
  addVertex() {
    const n = this.corners.length;
    const i = Math.floor(Math.random() * n);
    const p0 = this.corners[(i - 1 + n) % n];
    const p1 = this.corners[i];
    const p2 = this.corners[(i + 1) % n];
    const p3 = this.corners[(i + 2) % n];
    const { cp1x, cp1y, cp2x, cp2y } = centripetalHandles(p0, p1, p2, p3, cornerRadius);
    const c = new Corner();
    c.x = 0.125*p1.x + 0.375*cp1x + 0.375*cp2x + 0.125*p2.x;
    c.y = 0.125*p1.y + 0.375*cp1y + 0.375*cp2y + 0.125*p2.y;
    const boost = 0.5 + Math.random() * 2.0; // random speed 0.5×–2.5× so new vertex diverges
    c.vx = (p1.vx + p2.vx) / 2 * boost;
    c.vy = (p1.vy + p2.vy) / 2 * boost;
    this.corners.splice(i + 1, 0, c);
  }

  // Remove a vertex by having it pursue its neighbor directly —
  // no insertion needed; Catmull-Rom handles the smooth disappearance
  removeVertex() {
    if (this.corners.length <= 2) return;
    if (this.corners.some(c => c.lerpTarget)) return;
    const n = this.corners.length;
    const i = Math.floor(Math.random() * n);
    this.corners[i].lerpTarget = this.corners[(i + 1) % n];
  }

  // Draw to either the main ctx (color) or offscreen octx (B&W)
  drawTo(target, isColor) {

    const drawPoly = (pts, tension) => {
      const n = pts.length;
      target.beginPath();
      target.moveTo(pts[0].x, pts[0].y);
      for (let i = 0; i < n; i++) {
        const p0 = pts[(i - 1 + n) % n];
        const p1 = pts[i];
        const p2 = pts[(i + 1) % n];
        const p3 = pts[(i + 2) % n];
        if (!tension) { target.lineTo(p2.x, p2.y); continue; }
        const { cp1x, cp1y, cp2x, cp2y } = centripetalHandles(p0, p1, p2, p3, tension);
        target.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
      }
    };

    // When trail is 0, just draw the current position as a single bright line
    if (this.trailLength === 0) {
      const round = lineThickness > 1;
      target.lineJoin = round ? 'round' : 'miter';
      target.lineCap  = round ? 'round' : 'butt';
      target.lineWidth = lineThickness;
      const pts = this.corners;
      drawPoly(pts, cornerRadius);
      target.strokeStyle = isColor ? `hsla(${this.hue}, 100%, 65%, 1)` : '#fff';
      target.stroke();
      return;
    }

    const len = this.history.length;
    const drawEntry = (i) => {
      const entry = this.history[i];
      const alpha = entry.alpha;
      const pts = entry.pts;
      const thick = entry.thickness;
      const curve = entry.curve;
      const round = thick > 1;
      target.lineJoin = round ? 'round' : 'miter';
      target.lineCap  = round ? 'round' : 'butt';
      target.lineWidth = thick;
      let strokeStyle;
      if (isColor) {
        const h = (this.hue - (len - i) / len * 180 + 360) % 360;
        strokeStyle = `hsla(${h}, 100%, 65%, ${alpha})`;
      } else {
        const brightness = Math.round(alpha * 255);
        strokeStyle = `rgb(${brightness},${brightness},${brightness})`;
      }
      drawPoly(pts, curve);
      target.strokeStyle = strokeStyle;
      target.stroke();
    };

    for (let i = 0; i < len; i += this.drawStep) {
      drawEntry(i);
    }
    // Newest entry always drawn — guarantees head is included even when drawStep skips it
    if (len > 0) drawEntry(len - 1);
  }
}

function initShapes(count) {
  trails = [];
  const hues = [0, 120, 210, 280, 40, 170];
  const trailLength = trailOverride;
  const drawStep = gapOverride;
  for (let i = 0; i < count; i++) {
    trails.push(new Shape(numVertices, hues[i % hues.length] + Math.random() * 30, trailLength, drawStep));
  }
  // Reset offscreen when shapes change
  octx.fillStyle = '#000';
  octx.fillRect(0, 0, W, H);
}

// Apply Bayer ordered dithering: reads grayscale offscreen, writes 1-bit to main canvas
function ditherToMain() {
  const srcData = octx.getImageData(0, 0, W, H);
  const src = srcData.data;

  // Write dithered output directly
  const dstData = ctx.createImageData(W, H);
  const dst = dstData.data;

  for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
      const idx = (y * W + x) * 4;
      const gray = src[idx] / 255; // 0..1
      // Crush near-black values to zero before dithering — prevents residue dots
      // from very faint lines that would otherwise pepper sparse Bayer pixels
      const crushed = gray < 0.12 ? 0 : gray;
      const threshold = BAYER8[(y % 8) * 8 + (x % 8)];
      const bit = crushed > threshold ? 255 : 0;
      dst[idx]     = bit;
      dst[idx + 1] = bit;
      dst[idx + 2] = bit;
      dst[idx + 3] = 255;
    }
  }

  ctx.putImageData(dstData, 0, 0);
}

// Helper: convert fade slider int 1-10 → fadeAlpha
function fadeValToAlpha(v) {
  return (v - 1) / 9; // 0 (no fade, all lines equal) → 1 (linear gradient across all lines)
}

// Update a single wander property — nudge val by vel, bounce at boundaries.
// If w.fold is defined, the internal val can go below the fold point;
// the returned effective value mirrors back up: fold + abs(val - fold).
// This lets the wander cross the minimum naturally rather than bouncing off it.
function wanderStep(w, rate) {
  w.vel += (Math.random() - 0.5) * rate;
  w.vel *= 0.85;
  w.val += w.vel;
  if (w.val < w.min) { w.val = w.min; w.vel = Math.abs(w.vel); }
  if (w.val > w.max) { w.val = w.max; w.vel = -Math.abs(w.vel); }
  const effective = w.fold !== undefined ? w.fold + Math.abs(w.val - w.fold) : w.val;
  return Math.round(effective / w.step) * w.step;
}

function tickWander(timestamp) {
  if (wanderSpeed === 0) return;
  if (timestamp - wanderTimer < WANDER_INTERVAL) return;
  wanderTimer = timestamp;

  // Rate scales with wander speed (1=very slow, 10=fast)
  const rate = wanderSpeed * 0.08;
  const fadeLabels = ['min','','slow','','med','','fast','','','max'];

  // Fade
  const newFadeV = Math.round(wanderStep(wander.fade, rate * 0.5));
  fadeAlpha = fadeValToAlpha(newFadeV);
  document.getElementById('fadeSlider').value = newFadeV;
  document.getElementById('fadeVal').textContent = fadeLabels[newFadeV - 1] || newFadeV;

  // Speed
  const newSpeed = Math.round(wanderStep(wander.speed, rate * 0.2) / 0.1) * 0.1;
  speedMult = newSpeed;
  document.getElementById('speedSlider').value = newSpeed;
  document.getElementById('speedVal').textContent = newSpeed.toFixed(1) + '×';

  // Thickness
  const newThick = Math.round(wanderStep(wander.thickness, rate * 0.4) / 0.5) * 0.5;
  lineThickness = newThick;
  document.getElementById('thickSlider').value = newThick;
  document.getElementById('thickVal').textContent = newThick % 1 === 0 ? newThick : newThick.toFixed(1);

  // Vertices — add/remove one at a time, no screen clear
  const newVerts = Math.round(wanderStep(wander.vertices, rate * 1.0));
  if (newVerts !== numVertices) {
    const delta = newVerts > numVertices ? 1 : -1;
    numVertices += delta;
    trails.forEach(t => delta > 0 ? t.addVertex() : t.removeVertex());
    document.getElementById('vertSlider').value = numVertices;
    document.getElementById('vertVal').textContent = numVertices;
  }

  // Trail — fold at 0, handled by wanderStep
  const newTrail = Math.round(wanderStep(wander.trail, rate * 3));
  if (newTrail !== trailOverride) {
    trailOverride = newTrail;
    trails.forEach(t => { t.trailLength = newTrail; });
    document.getElementById('trailSlider').value = newTrail;
    document.getElementById('trailVal').textContent = newTrail;
  }

  // Shapes — add/remove one at a time, dying shapes fade out naturally
  const newShapes = Math.round(wanderStep(wander.shapes, rate * 0.3));
  const liveCount = trails.filter(t => !t.dying).length;
  if (newShapes !== liveCount) {
    const delta = newShapes > liveCount ? 1 : -1;
    if (delta > 0) {
      const hues = [0, 120, 210, 280, 40, 170];
      const i = trails.filter(t => !t.dying).length;
      trails.push(new Shape(2, hues[i % hues.length] + Math.random() * 30, trailOverride, Math.ceil(Math.random() * 8), { x: Math.random() * W, y: Math.random() * H }));
    } else {
      trails.find(t => !t.dying).dying = true;
    }
    document.getElementById('linesSlider').value = newShapes;
    document.getElementById('linesVal').textContent = newShapes;
  }

  // Curve — fold at 0, handled by wanderStep
  const newCurve = Math.round(wanderStep(wander.curve, rate * 0.4));
  cornerRadius = newCurve / 10;
  document.getElementById('curveSlider').value = newCurve;
  document.getElementById('curveVal').textContent = newCurve;

  // Grow new shapes toward current vertex count one step at a time
  trails.forEach(t => {
    if (!t.dying && t.corners.length < numVertices) t.addVertex();
  });
}

function loop(timestamp) {
  tickWander(timestamp);

  const interval = 1000 / targetFps;
  if (timestamp - lastFrameTime >= interval) {
    lastFrameTime = timestamp - ((timestamp - lastFrameTime) % interval);

    if (colorMode) {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);
      trails.forEach(t => { t.update(); t.drawTo(ctx, true); });
    } else {
      octx.fillStyle = '#000';
      octx.fillRect(0, 0, W, H);
      trails.forEach(t => { t.update(); t.drawTo(octx, false); });
      ditherToMain();
    }
    trails = trails.filter(t => !t.isDead());

    if (debugMode) {
      ctx.save();
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 1;
      trails.forEach(t => {
        const cs = t.corners;
        const n = cs.length;
        for (let i = 0; i < n; i++) {
          const p0 = cs[(i - 1 + n) % n];
          const a  = cs[i];
          const b  = cs[(i + 1) % n];
          const p3 = cs[(i + 2) % n];
          // Midpoint circle at centripetal bezier t=0.5
          const { cp1x, cp1y, cp2x, cp2y } = centripetalHandles(p0, a, b, p3, cornerRadius);
          const mx = 0.125*a.x + 0.375*cp1x + 0.375*cp2x + 0.125*b.x;
          const my = 0.125*a.y + 0.375*cp1y + 0.375*cp2y + 0.125*b.y;
          ctx.beginPath();
          ctx.arc(mx, my, 5, 0, Math.PI * 2);
          ctx.stroke();
          // Vertex triangle
          const r = 7;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y - r);
          ctx.lineTo(a.x + r * 0.866, a.y + r * 0.5);
          ctx.lineTo(a.x - r * 0.866, a.y + r * 0.5);
          ctx.closePath();
          ctx.stroke();
        }
      });
      ctx.restore();
    }
  }

  requestAnimationFrame(loop);
}

// Controls
const btnColor = document.getElementById('btnColor');
const btnBW = document.getElementById('btnBW');
btnColor.addEventListener('click', () => {
  colorMode = true;
  btnColor.classList.add('active');
  btnBW.classList.remove('active');
  // Clear main canvas when switching to color
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);
});
btnBW.addEventListener('click', () => {
  colorMode = false;
  btnBW.classList.add('active');
  btnColor.classList.remove('active');
  // Reset offscreen when switching to B&W
  octx.fillStyle = '#000';
  octx.fillRect(0, 0, W, H);
});

document.getElementById('linesSlider').addEventListener('input', (e) => {
  const count = parseInt(e.target.value);
  document.getElementById('linesVal').textContent = count;
  const hues = [0, 120, 210, 280, 40, 170];
  while (trails.length < count) {
    const i = trails.length;
    trails.push(new Shape(2, hues[i % hues.length] + Math.random() * 30, trailOverride, Math.ceil(Math.random() * 8), { x: Math.random() * W, y: Math.random() * H }));
  }
  while (trails.filter(t => !t.dying).length > count) {
    trails.find(t => !t.dying).dying = true;
  }
  wander.shapes.val = count;
});

document.getElementById('trailSlider').addEventListener('input', (e) => {
  trailOverride = parseInt(e.target.value);
  document.getElementById('trailVal').textContent = trailOverride;
  trails.forEach(t => { t.trailLength = trailOverride; });
  wander.trail.val = trailOverride;
});

document.getElementById('vertSlider').addEventListener('input', (e) => {
  const target = parseInt(e.target.value);
  document.getElementById('vertVal').textContent = target;
  while (numVertices < target) { trails.forEach(t => t.addVertex()); numVertices++; }
  while (numVertices > target) { trails.forEach(t => t.removeVertex()); numVertices--; }
  wander.vertices.val = numVertices;
});

document.getElementById('gapSlider').addEventListener('input', (e) => {
  gapOverride = parseInt(e.target.value);
  document.getElementById('gapVal').textContent = gapOverride;
  trails.forEach(t => { t.drawStep = gapOverride; });
});

document.getElementById('speedSlider').addEventListener('input', (e) => {
  speedMult = parseFloat(e.target.value);
  wander.speed.val = speedMult;
  document.getElementById('speedVal').textContent = speedMult.toFixed(1) + '×';
});

document.getElementById('fadeSlider').addEventListener('input', (e) => {
  const v = parseInt(e.target.value);
  fadeAlpha = fadeValToAlpha(v);
  wander.fade.val = v;
  const labels = ['min','','slow','','med','','fast','','','max'];
  document.getElementById('fadeVal').textContent = labels[v - 1] || v;
});

document.getElementById('wanderSlider').addEventListener('input', (e) => {
  wanderSpeed = parseInt(e.target.value);
  document.getElementById('wanderVal').textContent = wanderSpeed === 0 ? 'off' : wanderSpeed;
  // Sync wander state to current slider values when enabling
  if (wanderSpeed > 0) {
    wander.fade.val      = (() => { const fv = Math.round(1 + (Math.min(fadeAlpha, 0.31) - 0.01) / 0.3 * 9); return Math.max(1, Math.min(10, fv)); })();
    wander.speed.val     = speedMult;
    wander.thickness.val = lineThickness;
    wander.vertices.val  = numVertices;
    wander.trail.val     = trailOverride;
    wander.shapes.val    = trails.filter(t => !t.dying).length;
    wander.curve.val     = Math.round(cornerRadius * 10);
  }
});

document.getElementById('fpsSlider').addEventListener('input', (e) => {
  targetFps = parseInt(e.target.value);
  document.getElementById('fpsVal').textContent = targetFps;
});

document.getElementById('thickSlider').addEventListener('input', (e) => {
  lineThickness = parseFloat(e.target.value);
  wander.thickness.val = lineThickness;
  document.getElementById('thickVal').textContent = lineThickness % 1 === 0 ? lineThickness : lineThickness.toFixed(1);
});

document.getElementById('curveSlider').addEventListener('input', (e) => {
  const v = parseInt(e.target.value);
  cornerRadius = v / 10;
  wander.curve.val = v;
  document.getElementById('curveVal').textContent = v;
});

document.getElementById('btnRandom').addEventListener('click', () => {
  const pick = (min, max, step) => {
    const steps = Math.round((max - min) / step);
    return min + Math.round(Math.random() * steps) * step;
  };

  const shapes = pick(1, 6, 1);
  const trail  = pick(0, 120, 1);
  const verts  = pick(2, 16, 1);
  const gap    = pick(1, 8, 1);
  const fade   = pick(1, 10, 1);
  const speed  = pick(0.2, 4, 0.1);
  const fps    = pick(5, 60, 1);
  const thick  = pick(1, 10, 0.5);
  const curve  = pick(0, 10, 1);

  // Apply values
  trailOverride = trail;
  numVertices   = verts;
  gapOverride   = gap;
  speedMult     = speed;
  targetFps     = fps;
  lineThickness = thick;
  cornerRadius  = curve / 10;
  fadeAlpha     = fadeValToAlpha(fade);

  // Sync wander state to new values
  wander.fade.val      = fade;
  wander.speed.val     = speed;
  wander.thickness.val = thick;
  wander.shapes.val    = shapes;
  wander.curve.val     = curve;

  // Update sliders
  document.getElementById('linesSlider').value = shapes;
  document.getElementById('linesVal').textContent = shapes;
  document.getElementById('trailSlider').value = trail;
  document.getElementById('trailVal').textContent = trail;
  document.getElementById('vertSlider').value = verts;
  document.getElementById('vertVal').textContent = verts;
  document.getElementById('gapSlider').value = gap;
  document.getElementById('gapVal').textContent = gap;
  document.getElementById('fadeSlider').value = fade;
  const fadeLabels = ['min','','slow','','med','','fast','','','max'];
  document.getElementById('fadeVal').textContent = fadeLabels[fade - 1] || fade;
  document.getElementById('speedSlider').value = speed;
  document.getElementById('speedVal').textContent = speed.toFixed(1) + '×';
  document.getElementById('thickSlider').value = thick;
  document.getElementById('thickVal').textContent = thick % 1 === 0 ? thick : thick.toFixed(1);
  document.getElementById('curveSlider').value = curve;
  document.getElementById('curveVal').textContent = curve;

  initShapes(shapes);
});

// Show/hide UI on tap/click
const ui = document.getElementById('ui');

function showUI() {
  ui.classList.add('visible');
}
function hideUI() {
  ui.classList.remove('visible');
}

canvas.addEventListener('pointerdown', () => {
  ui.classList.contains('visible') ? hideUI() : showUI();
});

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' && e.target === document.body) {
    e.preventDefault();
    ui.classList.contains('visible') ? hideUI() : showUI();
  }
  if (e.code === 'KeyD' && e.target === document.body) {
    debugMode = !debugMode;
    if (debugMode) {
      // Save current state
      debugPrev = {
        wanderSpeed,
        trailOverride,
        shapes: trails.filter(t => !t.dying).length,
      };
      // Apply debug: wander off, 1 shape, no trail
      wanderSpeed = 0;
      document.getElementById('wanderSlider').value = 0;
      document.getElementById('wanderVal').textContent = 'off';

      // Mark excess shapes as dying BEFORE changing trailLength so they
      // retain their current trailLength and drain their history naturally
      while (trails.filter(t => !t.dying).length > 1) {
        trails.find(t => !t.dying).dying = true;
      }
      document.getElementById('linesSlider').value = 1;
      document.getElementById('linesVal').textContent = 1;

      // Only zero out trail on the surviving shape
      trailOverride = 0;
      trails.forEach(t => { if (!t.dying) t.trailLength = 0; });
      document.getElementById('trailSlider').value = 0;
      document.getElementById('trailVal').textContent = 0;
    } else {
      // Restore saved state
      wanderSpeed = debugPrev.wanderSpeed;
      document.getElementById('wanderSlider').value = wanderSpeed;
      document.getElementById('wanderVal').textContent = wanderSpeed === 0 ? 'off' : wanderSpeed;

      trailOverride = debugPrev.trailOverride;
      trails.forEach(t => { t.trailLength = trailOverride; });
      document.getElementById('trailSlider').value = trailOverride;
      document.getElementById('trailVal').textContent = trailOverride;

      const targetShapes = debugPrev.shapes;
      const hues = [0, 120, 210, 280, 40, 170];
      const liveCount = trails.filter(t => !t.dying).length;
      for (let i = liveCount; i < targetShapes; i++) {
        trails.push(new Shape(2, hues[i % hues.length] + Math.random() * 30, trailOverride, Math.ceil(Math.random() * 8), { x: Math.random() * W, y: Math.random() * H }));
      }
      document.getElementById('linesSlider').value = targetShapes;
      document.getElementById('linesVal').textContent = targetShapes;
    }
  }
});

document.addEventListener('pointerdown', (e) => {
  if (!ui.contains(e.target) && e.target !== canvas) hideUI();
});


window.addEventListener('resize', () => {
  resize();
  initShapes(trails.length);
});

resize();
initShapes(NUM_SHAPES);
loop();
</script>
</body>
</html>
